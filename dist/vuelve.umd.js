(function(n,u){typeof exports=="object"&&typeof module<"u"?module.exports=u(require("vue"),require("lodash.clonedeep")):typeof define=="function"&&define.amd?define(["vue","lodash.clonedeep"],u):(n=typeof globalThis<"u"?globalThis:n||self,n.vuelve=u(n.Vue,n.cloneDeep))})(this,function(n,u){"use strict";const p=t=>typeof t=="function",y=t=>Array.isArray(t);function E(t){return typeof t=="object"&&(t.type===void 0||typeof t.type=="function"||t.type===!0)&&(t.required===void 0||typeof t.required=="boolean")&&(t.default===void 0||typeof t.default=="function"||t.type!==!0&&typeof t.default===t.type.name.toLowerCase())}const j={mounted:n.onMounted,beforeUpdate:n.onBeforeUpdate,updated:n.onUpdated,beforeUnmount:n.onBeforeUnmount,unmounted:n.onUnmounted,errorCaptured:n.onErrorCaptured,renderTracked:n.onRenderTracked,renderTriggered:n.onRenderTriggered,activated:n.onActivated,deactivated:n.onDeactivated,serverPrefetch:n.onServerPrefetch};function m(t){return function(f){const s={},a={},h={},w={},d={};if(t.props){const c=y(t.props);(c?Object.values(t.props):Object.keys(t.props)).forEach(e=>{var r;if(c)f&&f[e]&&(s[e]=f[e]);else{const o=t.props[e];if(E(o)){if(f&&f[e]){if(!o.type||o.type===!0)s[e]=f[e];else if(typeof o.type=="function")if(o.type.name===f[e].constructor.name)s[e]=f[e];else throw new TypeError(`Invalid prop: type check failed for prop "${e}". Expected ${(r=o.type)==null?void 0:r.name}, got ${f[e].constructor.name}`)}else if(o.default){const O=p(o.default)?o.default():o.default;s[e]=O}else if(o.required)throw new Error(`${e} is required but not provided.`)}if(!E(o)&&f&&f[e])if(o.name===f[e].constructor.name)s[e]=f[e];else throw new TypeError(`Invalid prop: type check failed for prop "${e}". Expected ${o.name}, got ${f[e].constructor.name}`)}})}if(t.data&&p(t.data)){const c=t.data();Object.entries(c).forEach(([i,e])=>{let r;typeof e=="object"&&e!==null?r=n.reactive(e):r=n.ref(u(e)),a[i]=r})}return Object.assign(d,a,s),t.methods&&Object.entries(t.methods).forEach(([c,i])=>{h[c]=i.bind(d)}),Object.assign(d,h),Object.entries(j).forEach(([c,i])=>{const e=c;if(t[e]){const r=t[e];i((...o)=>r.apply(d,o))}}),t.watch&&Object.entries(t.watch).forEach(([c,i])=>{const e=i,r=d[c];r&&n.watch(r,e.bind(d))}),t.watchEffect&&Object.values(t.watchEffect).forEach(c=>{const i=c;n.watchEffect(i.bind(d))}),t.computed&&Object.keys(t.computed).forEach(c=>{const i=t.computed&&t.computed[c];i&&(w[c]=n.computed(i.bind(d)))}),{...s,...a,...h,...w}}}return m});
